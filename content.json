{"meta":{"title":"橙寂博客","subtitle":null,"description":"橙寂博客,不忘初心","author":"橙寂","url":"http://blog.luckyhe.com"},"pages":[],"posts":[{"title":"Docker中安装nginx","slug":"lunix/Docker中安装nginx","date":"2019-07-17T09:53:29.606Z","updated":"2019-07-22T01:52:35.420Z","comments":true,"path":"2019/07/17/lunix/Docker中安装nginx/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/lunix/Docker中安装nginx/","excerpt":"","text":"准备1.拉取nginx镜像 直接去dockerhub官网然后搜索ngnix就行了 docker pull nginx:1.15.11(这个是我在用的一个版本) 2.科普 科普下因为docker中所有项目都是一个容器所以这边运行nginx后他的配置文件也是在容器中的修改不方便所以我们要把他挂载出来。docker中 nginx的配置文件路径为 /etc/nginx/nginx.conf 日志的路径为 /var/log/nginx资源路径为/etc/nginx/html以上为docker中运行nginx的默认配置路径 3.创建挂载的目录 mkdir -p /usr/local/nginx/{conf,conf.d,html,logs}(ps:创建的目录html下默认 conf 下是没文件的所以这边需要自己找配置文件)建议跟容器中配置文件保持一致（玩的很熟练的可无视） 4.配置文件详情 nginx.conf(nginx默认配置)注意资源路径要改成nginx容器的资源路径而不是主机的资源路径 举例:比如你把容器中某个目录/etc/html 映射到本机中的 /www 这时在配置文件中还是需要使用/etc/html而不是/www这个你配置文件挂载只是把容器中/etc/html 映射到/www，所以容器中只能识别/etc/html所以在配置文件中的一些路径依然要为容器中的路径。 这个文件是我从容器中拷贝出来的，直接复制过去就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 运行镜像1docker run -p 80:80 --name mynginx -v /usr/local/ngnix/logs/:/var/log/nginx -v /usr/local/ngnix/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/ngnix/html/:/etc/nginx/html -d nginx:1.15.11 如果出现一串密码样的就运行成功dasdaf444115445112445412454","categories":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}],"tags":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/tags/lunix/"},{"name":"centsos7","slug":"centsos7","permalink":"http://blog.luckyhe.com/tags/centsos7/"},{"name":"docker","slug":"docker","permalink":"http://blog.luckyhe.com/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.luckyhe.com/tags/nginx/"}],"keywords":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}]},{"title":"Lunix上安装docker","slug":"lunix/Lunix上安装docker","date":"2019-07-17T09:51:53.758Z","updated":"2019-07-17T09:52:52.547Z","comments":true,"path":"2019/07/17/lunix/Lunix上安装docker/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/lunix/Lunix上安装docker/","excerpt":"","text":"参考官网教程https://docs.docker.com/install/linux/docker-ce/centos/ 1. 准备工作 1、Linux7以上或者cent OS6及以上版本 2、内核3.1.0以上 3、64位操作系统uname - r 可以查看lunix版本内核 4.卸载旧版本 12345678sudo yum remove docker \\docker-client \\ docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\\\ docker-engine 5.安装所需的包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。 $ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 6.使用以下命令设置稳定存储库。 $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo2安装docker 1.yum安装 yum install docker-ce 查看版本 docker -v docker version 都可以 3.启动docker systemctl start docker 测试docker运行成功没 sudo docker run hello-world安装成功 设置开机启动 systemctl enable docker 2.停止docker systemctl stop docker","categories":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}],"tags":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/tags/lunix/"},{"name":"centsos7","slug":"centsos7","permalink":"http://blog.luckyhe.com/tags/centsos7/"},{"name":"docker","slug":"docker","permalink":"http://blog.luckyhe.com/tags/docker/"}],"keywords":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}]},{"title":"服务消费者（feign）","slug":"java/springclound/2.服务消费者（feign）","date":"2019-07-17T09:49:21.715Z","updated":"2019-07-17T09:51:01.156Z","comments":true,"path":"2019/07/17/java/springclound/2.服务消费者（feign）/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/java/springclound/2.服务消费者（feign）/","excerpt":"","text":"服务的消费者1.启动eureka-server跟provider2.新建一个springboot工程选中以下模块 pom文件详情如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.janhe&lt;/groupId&gt; &lt;artifactId&gt;consumer1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;consumer1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--加入熔断器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.书写项目核心配置文件详细配置如下 123456789eureka: client: serviceUrl: defaultZone: http://localhost:9000/eureka/server: port: 8050spring: application: name: serice-custum 4.测试1.编写接口.123456789101112131415161718package com.janhe.consumer1.service;import com.janhe.consumer1.service.Hystrix.HelloServiceFeedBack;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Service;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = &quot;service-provider&quot;)//指定服务的提供者@Servicepublic interface HelloService &#123; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = &quot;name&quot;) String name);&#125; 2.编写控制器1234567891011121314151617181920212223242526272829303132package com.janhe.consumer1.controller;import com.janhe.consumer1.service.HelloService;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;/** * @Auther: Jan * @Date: 2019-4-1 10:01 * @Description: */@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @Autowired RestTemplate restTemplate; @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam String name) &#123; return helloService.sayHiFromClientOne(name); &#125;&#125; 3.启动测试http://localhost:8050/hi?name=bbb","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://blog.luckyhe.com/tags/微服务/"},{"name":"java","slug":"java","permalink":"http://blog.luckyhe.com/tags/java/"},{"name":"springClound","slug":"springClound","permalink":"http://blog.luckyhe.com/tags/springClound/"},{"name":"feign","slug":"feign","permalink":"http://blog.luckyhe.com/tags/feign/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]},{"title":"服务的注册与治理（eureka）","slug":"java/springclound/1.服务的注册与治理（eureka）","date":"2019-07-17T09:46:53.506Z","updated":"2019-07-17T09:48:57.447Z","comments":true,"path":"2019/07/17/java/springclound/1.服务的注册与治理（eureka）/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/java/springclound/1.服务的注册与治理（eureka）/","excerpt":"","text":"服务的注册与治理（eureka） 1.新建一个maven父项目1.2 然后创建2个model工程:一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka provider。下面以server创建为例子–&gt;右键工程–&gt;创建model–&gt;选择 spring initialir（如果没有这个选项的参考idea中安装spring initializr）如图然后一直下一步 选择cloud discovery-&gt;eureka server–&gt;一直下一步 完成后pom文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.jange&lt;/groupId&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;eureka-server&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.3 启动一个服务注册中心，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加@EnableEurekaServer 这个注解行了如图：1.4 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml： 1234567891011121314server: port: 9000eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #正式环境注销 server: enable-self-preservation: false #是关闭自我保护模式，默认为true。 eviction-interval-timer-in-ms: 4000 #清理无效节点的时间间隔，默认 通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.1.5 eureka server 是有界面的，启动工程,打开浏览器访问： http://localhost:9000 ,界面如下： 三、创建一个服务提供者 (service-provide1)当service-provide1向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。创建过程同server类似注意选择eureka discovery,创建完pom.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.janhe&lt;/groupId&gt; &lt;artifactId&gt;priveder&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;priveder&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 然后在启动类eEurekaClient注解 //表明自己是服务的提供者其次在application.yaml文件上加上 1234567891011121314server: port: 8010spring: application: name: service-providereureka: client: serviceUrl: defaultZone: http://localhost:9000/eureka/ #注册中心 healthcheck: enabled: true # 开启健康检查（需要spring-boot-starter-actuator依赖） instance: lease-expiration-duration-in-seconds: 30 # 续约到期时间（默认90秒） lease-renewal-interval-in-seconds: 10 # 续约更新 写个控制器 12345678910111213141516171819202122package com.janhe.priveder.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @Auther: Jan * @Date: 2019-4-1 09:28 * @Description: */@RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @RequestMapping(&quot;/hello&quot;) public String home(@RequestParam String name) &#123; return &quot;hi &quot;+name+&quot;,port:&quot; +port; &#125;&#125; 最后启动项目先启动server然后在启动provider最后访问http://localhost:9000 ,界面如下：!如图服务已经注册到注册中心了","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://blog.luckyhe.com/tags/微服务/"},{"name":"java","slug":"java","permalink":"http://blog.luckyhe.com/tags/java/"},{"name":"eureka","slug":"eureka","permalink":"http://blog.luckyhe.com/tags/eureka/"},{"name":"springClound","slug":"springClound","permalink":"http://blog.luckyhe.com/tags/springClound/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]},{"title":"Java虚拟机的类加载机制","slug":"java/jvm/Java虚拟机的类加载机制","date":"2019-07-17T09:44:14.695Z","updated":"2019-07-17T09:45:34.094Z","comments":true,"path":"2019/07/17/java/jvm/Java虚拟机的类加载机制/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/java/jvm/Java虚拟机的类加载机制/","excerpt":"","text":"Java虚拟机的类加载机制类的加载机制类的加载过程为 在java中类型的加载，连接与初始化都是在程序运行期间完成 1.加载：查找并加载类的二进制数据（将类的class文件中的二进制数据读入内存，放在运行时（runtime））的方法区内。然后创建这个类的class对象（可以反映这个类的数据结构）。这个对象仅是一个class对象并不是实例。2.连接:连接可以分为三个步骤 验证：确保被加载类的正确性。验证不通过会报Java.lang.VerifyError。编译验证了，但是并不是所有的class都是由Java源码编译过来，所以进行类加载的时候虚拟机会去验证他。保证系统的安全性。验证分为四项;文件格式验证,元数据验证,字节码验证,符号引用验证 准备：为类的静态对象分配内存，并初始化为默认值（简单来说就是比如int a=1 在这个阶段是不会赋值1的而是赋个默认值） 解析：把类的符合引用转化为实际引用。就是之前是没有指针在虚拟机中都是以CONTENT等类型存在。这个过程会解析成指针的形式 3.初始化为类的静态变量，赋予正确的的值。（int a=1 为a赋值1）。如果有静态变量或者是static{}语句块编译器会生成一个”()”方法。当被使用了就会去执行这个方法。另外提一句父类的初始化方法优先级都是最高的。 另外还有两个4.使用: 使用分为两种 所有的java类必须在首次主动使用时才会初始化 主动使用:初始化类主动使用场景： 1.创建类的实例2.访问某个类的接口的静态变量。包括静态方法3.反射 Class.foName(xxx.xxx.user)4.初始化子类 会初始化paren类父类5.虚拟机启动时标记为启动类 被动使用：不会初始化类除了上面的方式其他的方式都属于被动引用下文中会介绍被动引用的例子 1.通过子类引用父类的静态变量子类不会初始化 父类源码 子类源码 测试 这里大家先自己先想一下会出现的结果是什么。这个很多企业会出这样一个面试题 这里的话子类调用了父类定义的静态变量子类时不会初始化的，所以这里的输出结果是“ParentClass Loder”另外大家自己再去做个试验把，在子类中定义静态字段，然后在测试类中调用子类的静态变量。一定自己去做一遍印象才会更加深刻。由以上两个例子可以得出以下结论。 结论对于静态字段来说，只有直接定义该字段的类才会被初始化初始化子类时，要父类全部初始化完了，子类才会初始化 2.通过数组来定义引用类，不会触发此类的初始化比如 Parent[] arr=new Parent[10];是不会触发初始化的。 3.测试常量 测试 结论直接调用常量是不会触发类的初始化的因为常量在项目启动的时候就加载到类的常量池中 注意 接口的加载过程跟类的加载过程是有点不同的，接口没有static{}语句块。但是虚拟机会为接口提供一个”()”类构造器用来初始化静态变量。具体接口为什么不同是针对（上文中的第四点）主动使用的初始化子类，一定要先初始化父类。在接口中初始化子类，并不一定会初始化父类，只有使用到了父接口时才会初始化如（父接口的定义的常量）。 类的加载器(ClassLoader) 在上文中提到的类的加载，所有类的加载都是通过类加载器来实现的而且类的加载器只做了这么一件事 ** 1.什么是类的加载器:** 虚拟机团队把类加载阶段中“通过查找类的全限定名来获取二进制流”这个动作放在虚拟机外部实现，来获取应用程序所需要的类。这个代码块叫做类的加载器 对于任何一个类都需要由加载类的加载器和这个类本生确定它在java虚拟中的唯一性换而言之同一个类如果加载它的类加载器不同那么这两个类便不相等。（这里的相等包括Class的Equal方法，isAssignableFrom方法,isInstance方法） 自定义类的加载器类加载器是可以自定义的，只是我们一般都默认使用内置的加载器 系统默认的类加载器（经常使用的） 启动类加载器（BootStrapClassLoader）:这个类加载器负责将jdk中rt.jar，或者是以-Xbootclasspath指定的，并且被虚拟机识别了的类库加载到内存中。启动类不可以无法程序调用 扩展类加载器（ExtensionClassLoder）:这个加载器负责加载lib下ext下的扩展包或者是以其他方式指定的，这个加载器开发者可以调用 应用程序类加载器（ApplicationClassLoader）：这个类加载器是系统中geSystemClassLoader的返回值，所以这个加载器也就是我们所说的系统加载器也是我们开发者可能最常用的。 双亲委派模型在我们的程序中都是这几种加载器一起配合加载的，所以这种模型也称双亲委派模型（除了顶层外都有父级）这个模型的流程是：每个类收到加载需求的时候，都是把这个请求委派给父级而不是自己就尝试加载。如果父级加载不了，子级才会加载（不是强制性的只是java设计者推荐给大家的开发模型）。 代码实现双亲委派模型","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckyhe.com/tags/Java/"},{"name":"jvm","slug":"jvm","permalink":"http://blog.luckyhe.com/tags/jvm/"},{"name":"类加载","slug":"类加载","permalink":"http://blog.luckyhe.com/tags/类加载/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]},{"title":"消息服务RabbitMQ","slug":"mq/消息服务RabbitMQ","date":"2019-07-17T09:42:11.195Z","updated":"2019-07-17T09:43:14.079Z","comments":true,"path":"2019/07/17/mq/消息服务RabbitMQ/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/mq/消息服务RabbitMQ/","excerpt":"","text":"绪言 之前使用过ActiveMQ,但是发现很大一部分都是在使用RabbitMQ,在springboot中整合RabbitMQ也是非常简洁的，所以这里决定学习一下RabbitMQ。要使用消息队列是非常简单，但是最好自己有一点了解。使用的时候会清楚一点，到时面试也有东西可以说。这篇博客大概的讲解一下我对于RabbitMQ的理解。下篇我会讲一下RabbitMQ的初体验。 RabbitMQ简介 RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现是一款消息中间件。 AMQP概述 上面提到了RabbitMQ是AMQP的实现。所以这边我们的了解下什么是AMQP协议 AMQP（高级消息队列协议）来自官网AMQP官网下面是我看了这篇内容对于AMQP协议的一些理解 1.AMQP是一种网络协议，因此发布者，使用者和代理都可以驻留在不同的计算机上。2.AMQP的消息传递模式，以下是消息传递模型图（这也是RabbitMq中消息传递的模式）消息发布到交换机，通常与邮局或邮箱进行比较。然后，Exchange 使用称为绑定的规则将 消息副本分发到队列。然后，代理将消息传递给订阅队列的消费者，或者消费者根据需要从队列中获取/拉取消息。（这就是AMQP消息传递的过程） RabbitMQ核心概念1.Exchange(交换机)与Binding路由（重要） 交换机与路由是AMQP与JMS协议很大不同的一个地方也是学习RabbitMq非常重要的一个地方理解了这个那么简单使用RabbitMq基本没问题了。所有这边我把这两个放在一起，虽然跟JMS有区别但本质是不变的使用的都是点对点策略，跟发布订阅策略。 1.1Binding路由在讲交换机之前我先讲下路由是咋一回事。在RabbitMq中消息首先发送信息给交换机，然后交换机跟据路由分发到符合条件的队列。所以路由就是把Quene(队列)跟交换机串起来的地方。只有通过了路由的对比消息才能成功发到队列上。在下文我会讲解是怎么一个匹配的。这边要先清楚这个概念，对下文才能更好的理解。 1.1交换器交换器用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别。 Direct 点对点策略 就跟微信私聊一样，一个人发，一个人接。 一个交换机绑定了多个队列，只有跟路由件匹配的队列才能收到信息。在点对点中一个路由件只能绑定一个交换机。 fanout 是发布订阅的一种，但是这一种忽略掉了路由件的影响，只要绑定了这个交换机的Quene(对列)都能收到消息。应用场景: 大型多人在线（MMO）游戏可以将其用于排行榜更新或其他全球活动 体育新闻网站可以使用扇出交换来近乎实时地向移动客户端分发分数更新 分布式系统可以广播各种状态和配置更新 群聊可以使用扇出交换在参与者之间分发消息（尽管AMQP没有内置的存在概念，因此XMPP可能是更好的选择） topic:是发布订阅的一种，只要绑定了这个交换机的Quene(对列)并且符合路由件规则的都能收到消息。这里的路由件规则一般有两种janhe.# 那也就是说以janhe.开头的队列都能收到信息。还有一种.news也就是说以news结尾的队列就能收到信息。（#匹配0个或多个单词，匹配一个单词） topic（主题交换）具有非常广泛的用例。每当问题涉及多个消费者/应用程序选择性地选择他们想要接收哪种类型的消息时，应考虑使用主题交换。示例用途： 分发与特定地理位置相关的数据，例如销售点 由多个工作人员完成的后台任务处理，每个工作人员能够处理特定的任务集 股票价格更新（以及其他类型的财务数据更新） 涉及分类或标记的新闻更新（例如，仅针对特定运动或团队）在云中协调不同类型的服务 分布式架构/特定于操作系统的软件构建或打包，每个构建器只能处理一个体系结构或操作系统 headers标题交换目前我没有使用过，而且使用场景很少。所以这边就不做讲解了。需要了解可以去官网看看。 2.Message（消息体）消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 3.Quene(对列) 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。这里提醒下要使用对列必须先创建 4.Publisher(发布者) 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 5.Connection 网络连接，比如一个TCP连接。 6.Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 7.Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 8.Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 9.broker消息队列服务器实体下图为整个消息服务器结构图 我的下一篇文章会写一下springBoot整合RabbitMq写下怎么去使用它。这是我的个人站点希望大佬指导批评橙寂博客","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://blog.luckyhe.com/tags/mq/"},{"name":"Java","slug":"Java","permalink":"http://blog.luckyhe.com/tags/Java/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.luckyhe.com/tags/RabbitMQ/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]},{"title":"史上最详细lunix上安装mysql(centos7)","slug":"lunix/史上最详细lunix上安装mysql(centos7)","date":"2019-07-17T09:29:39.670Z","updated":"2019-07-17T09:34:57.883Z","comments":true,"path":"2019/07/17/lunix/史上最详细lunix上安装mysql(centos7)/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/lunix/史上最详细lunix上安装mysql(centos7)/","excerpt":"","text":"绪言centos7跟其他版本有些区别，所以自己写了这么一篇。网上很多都是没用的，步骤不全。我这篇超级全。下面开始安装 首先一个全新的系统 yum update 一下 升级一下依赖包。 1.创建目录 mkdir /usr/local/mysql5.6 2.上传mysql镜像文件 这边我使用的是winscp连接工具直接上传。不同工具上传方式不同的。我上传的是rpm包所以不需要解压。如果是tar.gz结尾。需要解压解压mysqltar -xvf MySQL-5.6.44-1.el7.x86_64.rpm-bundle.tar //注意，是-xvf不是-zxvf 3.卸载centos自带的mariadb rpm -qa | grep mariadb rpm -e –nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 4.卸载mysql rpm -qa | grep mysql rpm -e –nodeps 文件名检查服务chkconfig –list | grep -i mysql //查看服务 chkconfig –del mysql 5.安装依赖yum install perl yum install net-tools yum -y install autoconf //此包安装时会安装Data:Dumper模块 6.增加mysq用户组（非必须）groupadd mysqluseradd -r -g mysql mysql //创建用户并把该用户加入到组mysql，这里的 -r是指该用户是内部用户，不允许外部登录passwd mysql //给用户mysql设置密码，需要输入2次 这一项非必须。、 7.开始安装（官网下载） 下载mysql rpm -ivh MySQL-client-5.6.44-1.el7.x86_64.rpm rpm -ivh MySQL-devel-5.6.44-1.el7.x86_64.rpm rpm -ivh MySQL-server-5.6.44-1.el7.x86_64.rpm 8.启动mysql检查状态：service mysql status 启动服务：service mysql start 找到默认密码 cat /root/.mysql_secret 绕过密码登录 mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp; //绕过密码登录 登录 mysql -uroot -p 如果执行了绕过密码登录这一步不需要输入密码 修改密码： SET PASSWORD = PASSWORD(‘root’); 赋予所有用户远程访问权限 grant all privileges on . to ‘root’@’%’ identified by ‘root’ with grant option; 刷新权限 flush privileges; 9.开放3306端口firewall-cmd –state firewall-cmd –permanent –zone=public –add-port=3306/tcp //添加3306端口 firewall-cmd –reload 11.把mysql加入开机自启chkconfig –list mysql //查看mysql服务 chkconfig mysqld on //开启MySQL服务自动开启命令 chkconfig mysql on //开启MySQL服务自动开启命令 11.mysql集合重要目录/var/lib/mysql 数据库文件 /usr/share/mysql 命令及配置文件 /usr/bin mysqladmin、mysqldump等命令 /usr/my.cnf 核心配置文件","categories":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}],"tags":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/tags/lunix/"},{"name":"centsos7","slug":"centsos7","permalink":"http://blog.luckyhe.com/tags/centsos7/"},{"name":"mysql","slug":"mysql","permalink":"http://blog.luckyhe.com/tags/mysql/"}],"keywords":[{"name":"lunix","slug":"lunix","permalink":"http://blog.luckyhe.com/categories/lunix/"}]},{"title":"消息队列的概述(MQ)","slug":"mq/消息队列的概述(MQ)","date":"2019-07-17T09:09:39.196Z","updated":"2019-07-17T09:41:00.363Z","comments":true,"path":"2019/07/17/mq/消息队列的概述(MQ)/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/mq/消息队列的概述(MQ)/","excerpt":"","text":"绪言 目前消息对列的使用还是很广泛的，很多公司对这一块技术都会有要求。比如kafka，activeMQ，RabbitMQ是目前使用较多消息中间件。博主目前使用过activeMQ跟RabbitMQ用起来差别也不大。所以这边看公司需要掌握其中一种就好了。 什么是消息队列 消息（Message）是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中而不管谁来取，消息使用者只管从MQ中取消息而不管谁发布的，这样发布者和使用者都不用知道对方的存在。 消息队列的主要形式 队列(quene) 点对点式 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列消息只有唯一的发送者和接受者，但并不是说只能有一个接收者通俗来说就是一对一的发消息举例子:qq私聊，微信私聊 主题（topic）发布订阅式 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息举例子 ：公众号发了个信息然后你关注了的人都能收到，微信群发。 消息队列协议1.JMS（Java Message Service）JAVA消息服务 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 2.AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容JMSRabbitMQ是AMQP的实现 ** 对比 **这两种规范在spring中都是支持的，所以随便使用哪个都是可以的我这边来说下他们的不同1.JMS是基于java api定义的所以他跨平台性较差2.AMQP它是一种网络线级协议所以他是跨平台的，跨语言特性较好3.AMQP中引用了交换机跟路由件的概念。提供的消息模型更多详情在下篇对rabbit的博客中讲解3.AMQP本质是基于byte传输的，支持序列化跟发序列化，在spring中集成的很好。 消息队列能干什么异步处理 场景:有这么一个场景就是注册了账号，需要发短信，又需要发送邮件。要以最快的速度去完成大家 会怎么去做。 解决方案: 第一种方法就是顺序先发短信，在发邮件第二种 使用多线程第三种 使用消息队列 应用解耦场景:在一个分布式应用中新增了一个商品 在搜索模块中要把这个商品静态化然后还要把这个商品加入到solr的索引库中。注意这是两个模块的功能。解决方案: 新增了商品发送一个消息，搜索模块订阅这个消息然后做功能。当然这里可能你别的模块也需要用到这个消息，这时只需要让别的模块也订阅这个消息就好了。 处理高并发场景:秒杀场景解决方案: 用户下单了发送一个消息到消息队列中，这时相应的服务在去消息队列中调用做相应的功能就好了。 我的下一篇文章会针对RabbitMQ做下介绍。这是我的个人站点希望大佬指导批评橙寂博客","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://blog.luckyhe.com/tags/mq/"},{"name":"Java","slug":"Java","permalink":"http://blog.luckyhe.com/tags/Java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]}]}