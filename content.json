{"meta":{"title":"橙寂博客","subtitle":null,"description":"橙寂博客,不忘初心","author":"橙寂","url":"http://blog.luckyhe.com"},"pages":[],"posts":[{"title":"消息队列的概述(MQ)","slug":"第一篇博客","date":"2019-07-17T09:18:18.465Z","updated":"2019-07-17T09:22:32.144Z","comments":true,"path":"2019/07/17/第一篇博客/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/第一篇博客/","excerpt":"","text":"绪言 目前消息对列的使用还是很广泛的，很多公司对这一块技术都会有要求。比如kafka，activeMQ，RabbitMQ是目前使用较多消息中间件。博主目前使用过activeMQ跟RabbitMQ用起来差别也不大。所以这边看公司需要掌握其中一种就好了。 什么是消息队列 消息（Message）是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中而不管谁来取，消息使用者只管从MQ中取消息而不管谁发布的，这样发布者和使用者都不用知道对方的存在。 消息队列的主要形式 队列(quene) 点对点式 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列消息只有唯一的发送者和接受者，但并不是说只能有一个接收者通俗来说就是一对一的发消息举例子:qq私聊，微信私聊 主题（topic）发布订阅式 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息举例子 ：公众号发了个信息然后你关注了的人都能收到，微信群发。 消息队列协议1.JMS（Java Message Service）JAVA消息服务 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 2.AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容JMSRabbitMQ是AMQP的实现 ** 对比 **这两种规范在spring中都是支持的，所以随便使用哪个都是可以的我这边来说下他们的不同1.JMS是基于java api定义的所以他跨平台性较差2.AMQP它是一种网络线级协议所以他是跨平台的，跨语言特性较好3.AMQP中引用了交换机跟路由件的概念。提供的消息模型更多详情在下篇对rabbit的博客中讲解3.AMQP本质是基于byte传输的，支持序列化跟发序列化，在spring中集成的很好。 消息队列能干什么异步处理 场景:有这么一个场景就是注册了账号，需要发短信，又需要发送邮件。要以最快的速度去完成大家 会怎么去做。 解决方案: 第一种方法就是顺序先发短信，在发邮件第二种 使用多线程第三种 使用消息队列 应用解耦场景:在一个分布式应用中新增了一个商品 在搜索模块中要把这个商品静态化然后还要把这个商品加入到solr的索引库中。注意这是两个模块的功能。解决方案: 新增了商品发送一个消息，搜索模块订阅这个消息然后做功能。当然这里可能你别的模块也需要用到这个消息，这时只需要让别的模块也订阅这个消息就好了。 处理高并发场景:秒杀场景解决方案: 用户下单了发送一个消息到消息队列中，这时相应的服务在去消息队列中调用做相应的功能就好了。 我的下一篇文章会针对RabbitMQ做下介绍。这是我的个人站点希望大佬指导批评橙寂博客","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.luckyhe.com/tags/JAVA/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.luckyhe.com/tags/MQ/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://blog.luckyhe.com/categories/后端/"}]},{"title":"Hello hexo","slug":"消息队列的概述(MQ)","date":"2019-07-17T09:09:39.196Z","updated":"2019-07-17T09:17:22.290Z","comments":true,"path":"2019/07/17/消息队列的概述(MQ)/","link":"","permalink":"http://blog.luckyhe.com/2019/07/17/消息队列的概述(MQ)/","excerpt":"","text":"绪言 目前消息对列的使用还是很广泛的，很多公司对这一块技术都会有要求。比如kafka，activeMQ，RabbitMQ是目前使用较多消息中间件。博主目前使用过activeMQ跟RabbitMQ用起来差别也不大。所以这边看公司需要掌握其中一种就好了。 什么是消息队列 消息（Message）是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中而不管谁来取，消息使用者只管从MQ中取消息而不管谁发布的，这样发布者和使用者都不用知道对方的存在。 消息队列的主要形式 队列(quene) 点对点式 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列消息只有唯一的发送者和接受者，但并不是说只能有一个接收者通俗来说就是一对一的发消息举例子:qq私聊，微信私聊 主题（topic）发布订阅式 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息举例子 ：公众号发了个信息然后你关注了的人都能收到，微信群发。 消息队列协议1.JMS（Java Message Service）JAVA消息服务 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 2.AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容JMSRabbitMQ是AMQP的实现 ** 对比 **这两种规范在spring中都是支持的，所以随便使用哪个都是可以的我这边来说下他们的不同1.JMS是基于java api定义的所以他跨平台性较差2.AMQP它是一种网络线级协议所以他是跨平台的，跨语言特性较好3.AMQP中引用了交换机跟路由件的概念。提供的消息模型更多详情在下篇对rabbit的博客中讲解3.AMQP本质是基于byte传输的，支持序列化跟发序列化，在spring中集成的很好。 消息队列能干什么异步处理 场景:有这么一个场景就是注册了账号，需要发短信，又需要发送邮件。要以最快的速度去完成大家 会怎么去做。 解决方案: 第一种方法就是顺序先发短信，在发邮件第二种 使用多线程第三种 使用消息队列 应用解耦场景:在一个分布式应用中新增了一个商品 在搜索模块中要把这个商品静态化然后还要把这个商品加入到solr的索引库中。注意这是两个模块的功能。解决方案: 新增了商品发送一个消息，搜索模块订阅这个消息然后做功能。当然这里可能你别的模块也需要用到这个消息，这时只需要让别的模块也订阅这个消息就好了。 处理高并发场景:秒杀场景解决方案: 用户下单了发送一个消息到消息队列中，这时相应的服务在去消息队列中调用做相应的功能就好了。 我的下一篇文章会针对RabbitMQ做下介绍。这是我的个人站点希望大佬指导批评橙寂博客","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.luckyhe.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"http://blog.luckyhe.com/categories/前端/后端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.luckyhe.com/tags/hexo/"},{"name":"Java","slug":"Java","permalink":"http://blog.luckyhe.com/tags/Java/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.luckyhe.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"http://blog.luckyhe.com/categories/前端/后端/"}]},{"title":"Hello hexo","slug":"hello-world","date":"2019-07-16T00:49:46.463Z","updated":"2019-07-17T08:58:05.368Z","comments":true,"path":"2019/07/16/hello-world/","link":"","permalink":"http://blog.luckyhe.com/2019/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.luckyhe.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"http://blog.luckyhe.com/categories/前端/后端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.luckyhe.com/tags/hexo/"},{"name":"Java","slug":"Java","permalink":"http://blog.luckyhe.com/tags/Java/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.luckyhe.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"http://blog.luckyhe.com/categories/前端/后端/"}]}]}